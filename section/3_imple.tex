\section{Implementation}
\label{sec:impl}

Our empirical study in Section~\ref{sec:study} 
shows that a FSM is implemented in a loop 
which does not have a constant trip count (or iteration number) 
and conditionally updates a state variable 
to transit to a new state in each iteration. 
Therefore, \Tool{} searches FSM loops
by first filtering loops with constant trip counts (Section~\ref{sec:constant}) 
and then identifying loops with state variable updates (Section~\ref{sec:variable}).
The ultimate goal of \Tool{} is to extract implemented FSMs, 
and thus we will discuss how \Tool{} figures out the five-element tuple 
($Q$, $\sum$, $\delta$, $s_0$, $F$) 
for an identified FMS in Section~\ref{sec:tuple}. 

Algorithm~\ref{alg:fsm} shows the workflow of \Tool{}.
\Tool{} takes the source code of a program as input
and outputs the five-element tuple (line 8) 
and source code information (line 9) for each 
implemented FSM in the program.  


\begin{algorithm}[!htb]
    \caption{Finite State Machine Extraction}
    \label{alg:fsm}
    \begin{algorithmic}[1]
        \Require source code of a program: \emph{P}
        \Function {\Tool}{$P$}
        \State initialize an empty FSM set \emph{S} = \{\}
        \For{each loop $l$ in $P$}
        	\If{$l$ has a constant trip count}
        		\State \textbf{continue}
        	\EndIf
        	 \If{$l$ has state variable updates}
        			\State t($Q$, $\sum$, $\delta$, $s_0$, $F$) $\gets$ ConstructFSM($l$)
        			\State locInfo $\gets$ ExtractLOCInfo($l$) 
        			\State S.Insert(t, locInfo)
        	\EndIf
        \EndFor
        \State \Return{$S$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\subsection{Filtering Loops with Constant Trip Counts}
\label{sec:constant}
As discussed in Section~\ref{sec:study},
a FSM is usually implemented using a loop 
and the loop processes one input in each iteration to decide 
whether to transit to a new state. 
In reality, it is very rare that a FSM can arrive at a final state 
after processing a constant number of inputs.
Our empirical study confirms this intuition. 
None of our studied FMS loops take a constant trip count.  
To sum up, given a loop which iterates a constant 
number in each execution, 
the loop is unlikely to be a FSM implementation. 

We mainly leverage scalar evolution analysis~\cite{scalar-1,scalar-2,scalar-3} 
to identify loops whose trip counts are constant. 
Scalar evolution analysis can identify reduction variables inside a loop.
Reduction variables are integer variables, 
whose values are updated 
with a constant delta in each loop iteration. 
For example, variable \texttt{right} is the only reduction 
variable inside the loop in Figure~\ref{fig:cgc-fsm}, 
since its value is incremented by one in every loop iteration.  
When a loop finishes its execution, the value change of a 
reduction variable is a multiplication of 
the iterations executed by the loop. 

After identifying reduction variables inside a loop,
\Tool{} checks whether any exit condition of the loop is to compare 
a reduction variable with a constant number. 
If so, then the loopâ€™s trip count is constant and \Tool{} filter out the loop. 
For example, the only reduction variable \texttt{right} is dereferenced 
in exit conditions of the loop in Figure~\ref{fig:cgc-fsm} 
and it is not compared with a constant number.
Therefore, \Tool{} does not filter out the loop and considers it 
as a potential FSM implementation 
for further analysis. 

\subsection{Pinpointing State Variables}
\label{sec:variable}
Our empirical study shows that state variables are either in integer or enumeration type
and a FSM loop conditionally conducts a state transition in each iteration. 
Therefore, a FSM loop must contain at least one memory write to an integer 
(or an enumeration) variable. 
Since transition functions need to refer to the current state, 
a value assigned to a state variable in one iteration of a FSM loop needs 
to propagate to future iterations.
Given a candidate FSM loop, 
\Tool{} leverages live variable 
analysis~\cite{live-analysis} to 
identify possible state variables, which are integer variables 
updated inside the loop and have updated values live outside the loop 
or in the next iteration. 


We illustrate this approach by taking the FSM 
in Figure~\ref{fig:cgc-fsm} for example. 
Variable \texttt{state} is an enumeration variable and it is assigned 
with a new value at 
line 17, 20, 25, 27, 29, and 35 inside the \texttt{while} loop. 
The updated values are possibly read at line 15, 23 and 32 
in the next iteration of the loop or at line 41 outside the loop.
Therefore, \Tool{} considers \texttt{state} as a possible 
state variable.  

We further eliminate false positives when identifying state variables 
by considering how a FSM conducts state transitions. 
As discussed in Section~\ref{sec:study}, 
a transition function refers to the current state to determine the next state. 
Therefore, defining the next state through writing a new value to a state variable 
is control dependent~\cite{cdg} on a predicate evaluation 
using the current value of the state variable.  
Take the FSM in Figure~\ref{fig:cgc-fsm} as an example, 
transiting to state \texttt{open\_set} at line 17
is control dependent on the evaluation of ``\texttt{state==start}''
where the value of \texttt{state} is read at line 15 and \texttt{start} is a constant. 
Transiting to \texttt{close\_double} at 
line 25 is control dependent on the 
evaluation of ``\texttt{state==open\_double}'', 
and the value of \texttt{state} is read at line 23.

\Tool{} implements this mechanism using the following two steps. 
First, for each memory write to an integer (or enumeration) 
variable inside a candidate loop, 
\Tool{} searches conditional branches inside the loop 
on which the memory write is control dependent. 
Second, \Tool{} checks whether the condition 
of a searched branch 
is data dependent on the same integer variable. 
For example, the memory write at line 17 is conducted on an enumeration variable
and it is control dependent on the underlying branch 
instruction represented by 
the \texttt{switch} at line 15 and the \texttt{case} at line 16.  
The condition of the branch is ``\texttt{state==start}'' and it is 
data dependent on the same enumeration variable \texttt{state}. 
Therefore, \Tool{} identifies \texttt{state} as a state variable. 



\subsection{Constructing FSMs}
\label{sec:tuple}
With a FSM loop and identified state variables, 
we now discuss how we construct the implemented FSM. 
Specifically, we need to figure out the five-element tuple for the identified FSM. 

