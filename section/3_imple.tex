\section{Implementation}
\label{sec:impl}

From our empirical study in Section~\ref{sec:study},
we observe that a FSM is implemented using a loop 
whose iteration number is not constant  
and the loop conditionally updates a state variable in each iteration. 
Therefore, \Tool{} extracts implemented FSMs from a program in three steps.
First, \Tool{} looks for loops without constant iteration numbers. 
Second, \Tool{} checks whether there are state 
variable updates inside the loops to identify FSM implementations. 
Third, \Tool{} applies a suite 
of static analysis to figure out states ($Q$), 
transition functions ($\delta$), the initial state ($s_0$),
and final states ($F$) for each FSM implementation. 


\subsection{Filtering Loops with Constant Trip Counts}
As we discussed in Section~\ref{sec:study},
a FSM is usually implemented using a loop 
and the loop processes one input in each iteration to decide 
whether to transit to a new state. 
In reality, it is very rare that a FSM can arrive at a final state 
after receiving a constant number of inputs. 
Therefore, given a loop which iterates a constant 
number during every execution, 
the loop is unlikely to be a FSM implementation. 


We mainly leverage scalar evolution analysis~\cite{scalar-1,scalar-2,scalar-3} 
to identify loops whose trip counts are constant. 
Scalar evolution analysis can identify reduction variables inside a loop.
Reduction variables are integer variables, 
whose values are updated 
with a constant delta in each loop iteration. 
For example, variable \texttt{right} is the only reduction 
variable inside the loop in Figure~\ref{fig:cgc-fsm}, 
since its value is incremented by one in every loop iteration.  
When a loop finishes its execution, the value change of a 
reduction variable is a multiplication of 
the iterations executed by the loop. 

After identifying reduction variables inside a loop,
\Tool{} checks whether any exit condition of the loop is to compare 
a reduction variable with a constant number. 
If so, then the loopâ€™s trip count is constant and \Tool{} filter out the loop. 
For example, the only reduction variable \texttt{right} is dereferenced 
in exit conditions of the loop in Figure~\ref{fig:cgc-fsm} 
and it is not compared with a constant number.
Therefore, \Tool{} does not filter out the loop and considers it 
as a potential FSM implementation 
for further analysis. 

\subsection{Pinpointing State Variables}

Our empirical study shows that state variables are either in integer or enumeration type
and a FSM loop conditionally conducts a state transition in each iteration. 
Therefore, a FSM loop must contain memory write to an integer 
(or an enumeration) variable. 
Since transition functions need to refer to the current state, 
a value assigned to a state variable in one iteration needs 
to propagate to future iterations of a FSM loop. 
Given a candidate FSM loop, \Tool{} leverages live variable 
analysis~\cite{live-analysis} to 
identify possible state variables, which are integer variables 
updated inside the loop and have updated values live outside the loop 
or in the next iteration. 

We illustrate this approach by taking the FSM 
in Figure~\ref{fig:cgc-fsm} for example. 
Variable \texttt{state} is an enumeration variable and it is updated at 
line 17, 20, 25, 27, 29, and 35 inside the while loop. 
The updated values are possibly read at line 15, 23 and 32 
in the next iteration or at line 41 outside the loop.
Therefore, \Tool{} identifies \texttt{state} as a possible 
state variable.  


We further eliminate false positives when identifying state variables 
by considering how a FSM conducts state transitions. 
As discussed in Section~\ref{sec:study}, 
a transition function refers to the current state to determine the next state. 
Therefore, defining the next state through writing a state variable 
is control dependent~\cite{cdg} on a predicate evaluation using the memory read value
from the state variable. 
For the FSM in Figure~\ref{fig:cgc-fsm}, 
transiting to state \texttt{open\_set} at line 17
is control dependent on the evaluation of ``\texttt{state==start}'' at line 15 and 16. 
and transiting to \texttt{close\_double} at line 25 is control dependent on the 
evaluation of ``\texttt{state==open\_double}'' at line 23 and line 24. 




\subsection{Extracting FSMs}

