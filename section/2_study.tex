\section{Empirical Study}
\label{sec:study}
In this section, we will first review the mathematical definition of FSM and then
we will describe our empirical study on how FSMs are implemented 
in real-world software. 

\noindent\textbf{Background.}
A finite state machine (FSM) is a mathematical computation model, 
which consists of several internal states and takes inputs from the outside.
At any time, a FSM can only be in one state. 
When a certain condition is satisfied, 
a FSM transits from one state to another state. 
A FSM can be specified using a five-element tuple ($Q$, $\sum$, $\delta$, $s_0$, $F$),
where $Q$ is a set of internal states, $\sum$ is an input alphabet, 
$\delta$ is a set of transition functions,
$s_0$ is the initial state, and $F$ is a set of final states. 

\noindent\textbf{Real-World Implementation.}
We leverage the DARPA CGC dataset~\cite{CGC} to 
understand how FSMs are implemented in the real world. 
We choose the CGC dataset, because it 
contains a large number of diverse programs simplified 
from real-world software and it 
is also widely used in security 
community~\cite{QSYM, Driller, VUzzer}. 


To conduct the study, we first randomly sample 
40 programs from the CGC dataset.
We then manually inspect the sampled programs and look for implementation of FSMs.
In total, we identify 24 implemented FSMs, 
and they are the targets of our study.
Figure~\ref{fig:cgc-fsm} shows one example.
Function \texttt{cgc\_parse\_set()} takes string \texttt{right} 
as input and returns \texttt{true} if \texttt{right} matches 
regular expression ``\verb/|("[^"]*")?|/''. 
Figure~\ref{fig:cgc} shows the implemented FSM. 
In total the FSM contains six different states 
and nine possible state transitions. 



\input{section/fig-cgc-code}

\input{section/fig-cgc-fsm}

To guide the implementation of \Tool{}, our empirical study 
is mainly conducted from the following aspects.


First, what code constructs are used to implement the studied FSMs?
Since our goal is to statically identify and extract implemented FSMs, 
we must know what code constructs to inspect. 
Not surprisingly, all our studied FSMs are implemented using a loop, 
like the \texttt{while} loop at line 13 in Figure~\ref{fig:cgc-fsm}.  
In each loop iteration, an implemented FSM processes an input and 
determines whether to stay in the current state or transit to a new state. 
The underlying intuition is that a FSM usually needs to process 
multiple inputs and similar logics are applied during the processing, 
so that using loop is a natural way to implement a FSM. 
Another important observation is that 
the loops used to implement the studied FSMs do not execute constant iterations,
and their executions dynamically depend on inputs. 
For example, the iteration number of the loop in Figure~\ref{fig:cgc-fsm}
is not constant and it 
depends on the content of input string \texttt{right}.


Second, how internal states ($Q$) are maintained by the FSMs?
Intuitively, there must be a state variable, which tracks the current state of a FMS. 
Our study confirms this intuition. 
We also find that state variables are either in integer type or enumeration type,
and their values are discrete and bounded in a certain range. 
This finding inspires us to apply static value set analysis~\cite{DEEPVSA,VSA} 
to determine all possible states of an implemented FSM.
For example, local variable \texttt{state} declared at line 11
is the state variable of the FSM in Figure~\ref{fig:cgc-fsm}.
It is in enumeration type.
In total, it has six possible values specified by the declaration of 
its type at line 1, corresponding to 
the six states in Figure~\ref{fig:cgc}.
Interestingly, one studied FSM loop contains two state variables,
and this case reminders us that developers could use one loop 
to implement multiple FSMs. 


Third, what is the input alphabet ($\sum$)? 
The input alphabet of a FSM is theoretically bounded by all possible values 
of the data type used to save inputs. 
For example, the input alphabet of the FSM 
in Figure~\ref{fig:cgc-fsm} 
contains all possible byte values.
There are also cases where an input alphabet is a subset of all possible values, 
and we think value set analysis can help refine 
the input alphabet for an identified FSM.
We also observe that during the implementation of a FSM, 
developers usually do not enumerate the processing rule for every possible
input value, 
and they tend to explicitly specify the rules only for several special values
and leave others to be handled by a default rule. 
For example, only the processing rules for `\verb/|/' and `''' 
are specified in Figure~\ref{fig:cgc-fsm}, 
and all other byte values are handled by 
the default rule at line 31. 

Four, how the transition functions ($\delta$) are implemented?
Transition functions take the current state and a value
in the alphabet as input and output the next state. 
We observe that transition functions are implemented
using control constructs (e.g., \texttt{if}, \texttt{switch}). 
For example, a transition function in Figure~\ref{fig:cgc-fsm} 
is implemented in line 14, 16 and 17. 
If the current state is \texttt{start} at line 16 and the current input value is 
`\verb/|/â€™ at line 14, the transition function outputs \texttt{open\_set}
as the next state at line 17. 
Line 22, line 24 and line 25 implement another transition function,
which consumes an input character `''' at line 22 and 
transits from the current state 
\texttt{open\_double} at line 24 to 
the next state \texttt{close\_double} at line 25. 


Five, how to specify the initial state ($s_0$) and the final states ($F$)? 
$s_0$ of a FSM can be specified 
by the value of the state variable before the execution of the FSM loop.
For example,  $s_0$ of the FSM in Figure~\ref{fig:cgc-fsm}
is \texttt{start}, which is the value of \texttt{state} 
before the loop execution at line 13. 
When a FSM loop finishes its execution, 
all possible values of the state variable
represent $F$ of the FSM. 
For example, there are two possible values of \texttt{state} when 
the loop in Figure~\ref{fig:cgc-fsm} finishes its execution, 
one is \texttt{error} and the other is \texttt{close\_set}.
These two values represent the two final states of 
the FSM in Figure~\ref{fig:cgc}.

To sum up, our empirical study shows that 
there are clearly code patterns used by developers to implement FSMs. 
In Section~\ref{sec:impl}, we will discuss how we leverage these patterns to build \Tool{}, 
which can extract implemented FSMs from a program. 




