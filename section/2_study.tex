\section{Empirical Study}
In this section, we will first review the mathematical definition of FSM and then 
we will describe our empirical study on how FSMs are implemented 
in real-world software. 

\noindent\textbf{Background.}
A finite state machine (FSM) is a mathematical computation model, 
which consists of several internal states and takes inputs from the outside.
At any time, a FSM can only be in one state. 
When a certain condition is satisfied, 
a FSM transits from one state to another state. 
A FSM can be specified using a five-element tuple ($Q$, $\sum$, $\delta$, $s_0$, $F$),
where $Q$ is a set of internal states, $\sum$ is an input alphabet, 
$\delta$ is a set of transition functions,
$s_0$ is an initial state, and $F$ is a set of final states. 

\noindent\textbf{Real-World Implementation.}
We leverage the DARPA CGC dataset~\cite{CGC} to 
understand how FSMs are implemented in the real world. 
We choose the CGC dataset, because it 
contains diverse programs simplified 
from real-world software and it is also widely used in security 
community~\cite{QSYM, Driller, VUzzer}. 


To conduct the study, we first randomly sample 
40 programs from the CGC dataset.
We then manually inspect the sampled programs and look for implementation of FSMs.
In total, we identify {\color{red}{XXX}} implemented FSMs, 
and they are the targets of our study.

To guide the implementation of \Tool{}, our empirical study 
is mainly conducted from the following four aspects. 

First, what code constructs are used to implement the FSMs?
Since our goal is to statically identify and extract implemented FSMs, 
we need to know what code constructs to inspect. 
Not surprisingly, all our studied FSMs are implemented using a loop. 
In each loop iteration, an implemented FSM 
decides whether to stay in the current state or transit to a new state. 
The underlying intuition is that a FSM usually needs to process 
more than one input and similar logics are applied during the processing, 
so that using loop is a natural way to implement a FSM. 

Second, how internal states ($Q$) are maintained by the FSMs?

Third, what are the input alphabet ($\sum$)? 

Four, how the transition functions ($\delta$) are implemented?

