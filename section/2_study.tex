\section{Empirical Study}
\label{sec:study}
In this section, we will first review the mathematical definition of FSM and then
we will describe our empirical study on how FSMs are implemented 
in real-world software. 

\noindent\textbf{Background.}
A finite state machine (FSM) is a mathematical computation model, 
which consists of several internal states and takes inputs from the outside.
At any time, a FSM can only be in one state. 
When a certain condition is satisfied, 
a FSM transits from one state to another state. 
A FSM can be specified using a five-element tuple ($Q$, $\sum$, $\delta$, $s_0$, $F$),
where $Q$ is a set of internal states, $\sum$ is an input alphabet, 
$\delta$ is a set of transition functions,
$s_0$ is the initial state, and $F$ is a set of final states. 

\noindent\textbf{Real-World Implementation.}
We leverage the DARPA CGC dataset~\cite{CGC} to 
understand how FSMs are implemented in the real world. 
We choose the CGC dataset, because it 
contains a large number of diverse programs simplified 
from real-world software and it 
is also widely used in security 
community~\cite{QSYM, Driller, VUzzer}. 


To conduct the study, we first randomly sample 
40 programs from the CGC dataset.
We then manually inspect the sampled programs and look for implementation of FSMs.
In total, we identify 25 implemented FSMs, 
and they are the targets of our study.

Figure~\ref{fig:cgc-fsm} shows one example of studied FSMs.
Function \texttt{cgc\_parse\_set()} takes string \texttt{right} 
as input and returns \texttt{true} if \texttt{right} matches 
regular expression ``\verb/|("[^"]*")?|/''. 
Figure~\ref{fig:cgc} shows the implemented FSM. 
In total the FSM contains six different states 
and nine possible state transitions. 

\input{section/fig-cgc-code}

\input{section/fig-cgc-fsm}

To guide the implementation of \Tool{}, our empirical study 
is mainly conducted from the following aspects.


First, what code constructs are used to implement the studied FSMs?
Since our goal is to statically identify and extract implemented FSMs, 
we must know what code constructs to inspect. 
Not surprisingly, all our studied FSMs are implemented using a loop, 
like the \texttt{while} loop at line 13 in Figure~\ref{fig:cgc-fsm}.  
In each loop iteration, an implemented FSM processes an input and 
determines whether to stay in the current state or transit to a new state. 
The underlying intuition is that a FSM usually needs to process 
multiple inputs and similar logics are applied during the processing, 
so that using loop is a natural way to implement a FSM. 

Another important observation is that 
the FSM loops do not execute constant 
iterations or take constant trip counts.
Their executions dynamically depend on inputs, 
since it is very rare that a FSM can arrive at a final 
state after processing a predefined, constant number of inputs. 
For example, the iteration number of the 
loop in Figure~\ref{fig:cgc-fsm}
is not constant and it
depends on the content of input string \texttt{right}.

Second, how internal states ($Q$) are maintained by the FSMs?
Intuitively, there must be a state variable, which tracks the current state of a FMS.
When state transition happens, 
the value of the state variable is changed. 
Our study confirms this intuition. 
We also find that state variables are either in integer type or enumeration type,
and their values are discrete and bounded in a certain range. 
This finding indicates that static value set analysis~\cite{DEEPVSA,VSA} 
can potentially determine all possible states of an implemented FSM.
For example, local variable \texttt{state} declared at line 11
is the state variable of the FSM in Figure~\ref{fig:cgc-fsm}.
It is in enumeration type.
In total, it has six possible values 
specified by its type declaration at line 1, 
corresponding to the six states in Figure~\ref{fig:cgc}.
Interestingly, one studied FSM loop contains two state variables,
and this case reminders us that developers could use one loop 
to implement multiple FSMs. 
We need to extract all of them when designing \Tool{}.



Third, what is the input alphabet ($\sum$)? 
The input alphabet of a FSM is theoretically bounded by all possible values 
of the data type used to represent inputs. 
For example, the input alphabet of the FSM 
in Figure~\ref{fig:cgc-fsm} contains all possible byte values.
There are also cases where an input alphabet is a subset of all possible values, 
and we think value set analysis can help refine 
the input alphabet for an identified FSM.

We observe that a FSM loop processes a distinct input in each iteration. 
Sometimes, a FSM loop needs to refer to a different memory location for a new input. 
Sometimes, a new input is written to the same 
location in each iteration before the FSM loop starts its procession.    
For example, \texttt{right} points to the input character 
processed by the FSM in each iteration. 
The value of \texttt{right} is incremented by one at line 38 in each iteration, 
so that the FSM reads a different memory location in each iteration. 

We also observe that during the implementation of a FSM, 
developers usually do not enumerate the processing rule for every possible
input value, 
and they tend to explicitly specify the rules only for several special values
and leave others to be handled by a default rule. 
For example, only the processing rules for `\verb/|/' and `''' 
are explicitly specified in Figure~\ref{fig:cgc-fsm}, 
and all other byte values are handled by 
the default rule at line 31. 

Four, how the transition functions ($\delta$) are implemented?
Transition functions take the current state and a value
in the alphabet as input and output the next state. 
A transition function is executed in each iteration, 
the FSM relies on the output value to decide whether to transit to a new state. 
We observe that transition functions are implemented
using control constructs (e.g., \texttt{if}, \texttt{switch}). 
For example, a transition function in Figure~\ref{fig:cgc-fsm} 
is implemented in line 14, 15, 16, and 17. 
If the current state is \texttt{start} 
at line 16 and the current input value is 
`\verb/|/' at line 14, the transition function outputs \texttt{open\_set}
as the next state at line 17. 
Line 22, 23, 24, and 25 implement another transition function,
which consumes an input character `''' at line 22 and 
transits from the current state 
\texttt{open\_double} at line 24 to 
the next state \texttt{close\_double} at line 25. 

Five, how to specify the initial state ($s_0$) and the final states ($F$)? 
$s_0$ of a FSM can be specified 
by the value of the state variable before the execution of the FSM loop.
For example,  $s_0$ of the FSM in Figure~\ref{fig:cgc-fsm}
is \texttt{start}, which is the value of \texttt{state} 
before the loop execution at line 13. 
When a FSM loop finishes its execution, 
all possible values of the state variable
represent $F$ of the FSM. 
For example, the \texttt{while} loop in Figure~\ref{fig:cgc-fsm} terminates 
its execution when finishing parsing string \texttt{right}, 
so that \texttt{state} can be any of the six values 
in the type declaration at line 1 
and any state of the FSM in 
Figure~\ref{fig:cgc} can be a final state. 


To sum up, our empirical study shows that 
there are clear code patterns used by developers to implement FSMs. 
In Section~\ref{sec:impl}, we will discuss how we 
leverage these patterns to build \Tool{}, 
which can automatically extract implemented FSMs from a program. 





