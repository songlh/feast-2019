\section{Empirical Study}
\label{sec:study}
In this section, we will first review the mathematical definition of FSM and then 
we will describe our empirical study on how FSMs are implemented 
in real-world software. 

\noindent\textbf{Background.}
A finite state machine (FSM) is a mathematical computation model, 
which consists of several internal states and takes inputs from the outside.
At any time, a FSM can only be in one state. 
When a certain condition is satisfied, 
a FSM transits from one state to another state. 
A FSM can be specified using a five-element tuple ($Q$, $\sum$, $\delta$, $s_0$, $F$),
where $Q$ is a set of internal states, $\sum$ is an input alphabet, 
$\delta$ is a set of transition functions,
$s_0$ is an initial state, and $F$ is a set of final states. 

\noindent\textbf{Real-World Implementation.}
We leverage the DARPA CGC dataset~\cite{CGC} to 
understand how FSMs are implemented in the real world. 
We choose the CGC dataset, because it 
contains a large number of diverse programs simplified 
from real-world software and the dataset 
is also widely used in security 
community~\cite{QSYM, Driller, VUzzer}. 


To conduct the study, we first randomly sample 
40 programs from the CGC dataset.
We then manually inspect the sampled programs and look for implementation of FSMs.
In total, we identify {\color{red}{XXX}} implemented FSMs, 
and they are the targets of our study.
Figure~\ref{fig:cgc-fsm} shows one example.
Function \texttt{cgc\_parse\_set()} takes string \texttt{right} 
as input and returns \texttt{true} if \texttt{right} matches 
regular expression ``\verb/|("[^"]*")?|/''. 
Figure~\ref{xxx} shows the FSM implemented by function \texttt{cgc\_parse\_set()}. 
In total the FSM contains six states 
and {\color{red} XXX} 
state transitions. 


\input{section/fig-cgc-fsm}

To guide the implementation of \Tool{}, our empirical study 
is mainly conducted from the following aspects. 

First, what code constructs are used to implement the FSMs?
Since our goal is to statically identify and extract implemented FSMs, 
we must know what code constructs to inspect. 
Not surprisingly, all our studied FSMs are implemented using a loop, 
like the \texttt{while} loop at line 13 in Figure~\ref{fig:cgc-fsm}.  
In each loop iteration, an implemented FSM 
decides whether to stay in the current state or transit to a new state. 
The underlying intuition is that a FSM usually needs to process 
more than one input and similar logics are applied during the processing, 
so that using loop is a natural way to implement a FSM. 
Another important observation is that 
the loops used to implement the studied FSMs do not execute constant iterations,
while their executions dynamically depend on inputs. 
For example, the iteration number of the loop in Figure~\ref{fig:cgc-fsm}
is not a constant value and it depends on the content of string \texttt{right}.


Second, how internal states ($Q$) are maintained by the FSMs?
Intuitively, the implementation of a FSM must contain a state variable, 
which tracks the current state of the FMS.
Our study confirms this intuition. 
We also find that state variables are either in integer type or enumeration type,
and their values are discrete and bounded in a certain range. 
This finding inspires us to apply static value set analysis~\cite{DEEPVSA,VSA} 
to determine all possible states of an implemented FSM.
For example, local variable \texttt{state} declared at line 11
is the state variable for the FSM in Figure~\ref{fig:cgc-fsm}.
It is in enumeration type.
In total, it has six possible values specified by the declaration of 
its type at line 1. 




Third, what are the input alphabet ($\sum$)? 

Four, how the transition functions ($\delta$) are implemented?

