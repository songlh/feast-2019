\section{Experiment}

\subsection{Methodology}

\noindent\textbf{Implementation and Platform.} 
We implement \Tool{} using LLVM-7.0.0~\cite{LLVM}, 
and conduct our experiments on a Linux machine, 
with E5-2630 CPU, 32GB memory and 3.10 kernel. 

\noindent\textbf{Benchmarks.}
\Tool{} is a tool to automatically extract FSMs implemented in a program. 
Since we build \Tool{} using LLVM, 
our current implementation can only work on C/C++ programs.  
However, we believe that our algorithm is general enough 
to be extended to other programming languages. 


To evaluate \Tool{}, we collect C/C++ programs from three sources. 
First, we evaluate \Tool{} on two programs collected in a CTF contest~\cite{ctf}, 
one contains a FSM, and the other one does not. 
Second, we leverage the DARPA CGC dataset~\cite{CGC}. 
In total, there are 200 programs in the CGC dataset.
As discussed in Section~\ref{sec:study}, 
we already use 40 of them to conduct our empirical study,
so that we use the remaining 160 programs in our evaluation.
Third, we apply \Tool{} to OpenVPN~\cite{openvpn}, 
which provides an implementation of virtual private network and 
is included in software packages of every released Linux version. 

\input{section/tab-app}

The benchmark information is shown in Table~\ref{tab:benchmark}.
In total, we use 163 different programs to evaluate \Tool{}.
All our benchmarks are either real software or 
simplified programs from real applications. 
They are either widely-used in the real world or popular in the security community. 
They cover programs in small, medium and large sizes, 
with lines of code ranging from 0.3 thousand to more than 100 thousand.  
We believe that our benchmarks are representative 
enough to evaluate the effectiveness of \Tool{}.

\noindent\textbf{Evaluation Setting.} 
For all our benchmark programs, we manually examine all their loops and 
identify all FSM loops. 
As shown in Table~\ref{tab:benchmark}, there are in 
total 66 FSMs.
Four FSM loops contain two state variables, 
and all other FMS loops contain exact one state variables.
Therefore, there are in total 70 FSMs implemented in all our benchmarks.  
We apply \Tool{} to all benchmark programs. 
We mainly compute metrics to answer two research 
questions regarding the coverage and accuracy of \Tool{}.

\textbf{Q1. Coverage:} whether \Tool{} can identify all implemented FSMs?
 
\textbf{Q2. Accuracy:} whether \Tool{} will report loops, which are FSM loops, 
generating false positives. 

\subsection{Experimental Results}

\input{section/tab-exp}

\noindent\textbf{Coverage.}
As shown in Table~\ref{tab:exp}, \Tool{} successfully identifies 
all the {\color{red} XXX} FSM loops 
from the benchmarks. Since there are four FSM loops containing 
two state variables and \Tool{} constructs a FSM for every identified state variable, 
there are in total {\color{red} XXX} extracted FSMs. 
\Tool{} does not have any false negative.

\input{section/fig-sv}

We then further inspect the characteristics of the identified FSMs. 
For most of the cases, state variables are local variable either in integer type or in 
enumeration type. There are {\color{red} XXX} FSMs with a global integer variable
as its state variable. For {\color{red} XXX} FSMs, 
their state variables are a field of a \texttt{struct}. 
Second, what are the possible values for 
Figure~\ref{fig:sv} shows the percentage of the FSMs for different state numbers. 
More than 80\% of FSMs contain either two states or three states. 
The percentage drops significantly when the state number is larger than three. 
There are two FSMs containing 11 states. 
These two FSMs have the largest state numbers among all the identified FSMs. 
For most of the cases,

\noindent\textbf{Accuracy.}
\Tool{} reports two false positives when analyzing CGC programs. 
One of the example is shown in Figure~\ref{XXX}


\subsection{Case Study}